
// Работа с блоком one
function myClick(event) {
    console.log('click');
    console.log('--------------------');
    console.log(event.target); // на ЧТО кликаем (если по #one, то все 3 раза <div id="one">One</div>)
    console.log('--------------------');
    console.log(this);
    //console.log(event);
}

/**
 *  Имеем вложенную структуру: html -> body -> div с id=one.
 *  Если кликнуть на блок с div #one, то myClick() выполниться два раза.
 *  При клике на #one событие сначала срабатывает на div, затем поднимается на родителя.
 *  Если у родителя будет прописано событие (напр. onclick), то оно сработает и на нём.
 *
 *  Т.е. при клике на #one console.log('click') выведется 3 раза!
 *
 *  Модель распространения события, которое заложено в стандарте.
 *  Когда происходит событие, это событие можно отследить на самом элементе, на котором
 *  это событие произошло, но после этого событие не исчезает никуда. Событие начинает
 *  распространяться по всем родителям, дойдя до самого верхнего уровня HTML документа
 *
 *  Чтобы различить, что конкретно выводиться 3 раза:
 *  1 раз в console.log(this); попадает <div id="one">One</div>
 *  2 раз в this попадает весь <body></body>
 *  3 раз в this попадает весь документ <html></html>
 *
 *  В итоге. Событие по #one всплывает, распространяясь по всем родителям.
 *  На каждом родителе можем понять, ГДЕ произошло это событие при помощи event.target
 *  и получить тот элемент, на котором сейчас находится с помощью this
 */

// Первый стиль написания кода
// document.querySelector('#one').onclick = myClick;
// document.querySelector('body').onclick = myClick;
// document.querySelector('html').onclick = myClick;


// Второй стиль написания кода.
// Когда событие отлавливается на ВСЁМ документе, а потом в зависимости от того
// элемента, на котором событие произошло, выполнять разные функции
document.onclick = function (event) {

    //console.log(event); // объект PointerEvent

    //console.log(event.target); // получаем элемент, на который кликаем

    // Если кликнули по id one.
    if (event.target.id === 'one') {
        console.log('кликнули на id = one');
    }

    /**
     * Также можно отследить событие по клику по data, class
     * имеет ли элемент какой-то class, если да, то выполняем.
     * Не нужны циклы, блоки.
     * Есть функция в Js hasClass, которая проверяет наличие класса в элементе.
     * И в зависимости от этого выполнять какое-то действие.
     * Также, если повешана data, name, то будет что-то выполняться
     */
}

//------------------------------------------------------------------------------


// Работа с блоком three и дочерним two
document.querySelector('.two').onclick = function (event) {
    event.stopPropagation();
    console.log('two!!!!!!');
}

document.querySelector('.three').onclick = function () {
    this.style.display = 'none';
}

/**
 * Когда кликаем на two событие onclick распространяется и на three,
 * так как у three прописано такое же событие onclick.
 * Если у three будет событие, например, ondblclick, то при onclick по two
 * команда this.style.display = 'none' не сработает
 *
 * Можно управлять перехватом события
 * https://learn.javascript.ru/event-bubbling
 * Функция event.stopPropagation() прекращает всплытие.
 * В каждой методе не стоит использовать данную функцию, а только там где она нужна!
 *
 * Таким образом, при необходимости, если блоки вложены друг в друга и на них
 * навешаны ОДИНАКОВЫЕ события, которые не должны выполняться при клике по внутреннему
 * блоку, то всегда можно остановить всплытие событий в нужном месте!
 */