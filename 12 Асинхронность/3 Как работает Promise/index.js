/* 
  Client -> Server -> DataBase -> Server -> Client
*/
/**
 * Перезапись callback на промисы
 *
 * Идея промисов заключается в том, что создаём какой-то
 * объект Promise и оборачиваем в него какой-то асинхронный код.
 * Дальше можем более удобно манипулировать различными асинхронными
 * командами.
 * Получается удобно последовательно обрабатывать запросы
 *
 * 1============================
 * Первый шаг, для того чтобы создать оболочку для какого-то асинхронного кода
 * Т.е. создать Promise. В конструктор должны передать функцию, которая
 * принимает 2 параметра. Идея данной функции заключается, что в ней может
 * происходить любой асинхронный код, где промис его сразу же обработает.
 * Функция выполняется сразу!
 *
 * Далее через объект promise можно работать с кодом в данной функции
 *
 * 1.2
 * Внутри тела
 *
 * Для того чтобы Promise сработал. Идея заключается в том, что
 * сами сигнализируем промису о том, когда он завершился.
 * Для того чтобы реализовать данную возможность в функцию передаём
 * 2 функции resolve и reject
 *
 * Функция resolve вызывается тогда, когда закончили какую-то асинхронную операцию
 * В нашем случае, для того чтобы сигнализировать о том что завершили данный этап можно вызвать
 * сразу resolve после того как пройдёт setTimeout
 *
 * Функция reject служит для того же самого, но единственно сигнализирует об ошибке
 *
 * Т.е. resolve - успешное выполнение кода, а reject - какая-то ошибка
 *
 *
 * 2==========================================
 * У объекта promise есть две функции: then() и catch()
 *
 * promise.then() читается так: есть promise и когда что-то произойдёт,
 * т.е. когда сделаем resolve(); тогда вызовется then
 *
 * then() принимает функцию callback. В ней описывается логика, которая
 * будет происходить после того как выполнится асинхронный код.
 * В нашем случае должны обратиться к БД, и сформировать список пользователей
 * Это сделаем за 500 м/с
 *
 * В setTimeout происходят асинхронные операции
 * Можно обернуть асинхронный код в новый Promise (new Promise),
 * чтобы лучше управлять конструкцией setTimeout. Где в setTimeout, тогда когда
 * произойдёт формирование списка пользователей из БД, то вызовем функцию resolve()
 *
 * Неверный подход!
 * Есть промис bdPromise, к которому можно обратиться bdPromise.then(function ()) ...
 * Но есть проблема - погружаемся в глубину - callback в callback.
 *
 * Если нужно сделать последовательные действия асинхронных запросов,
 * то можно НЕ погружаться в глубину по callback-ам, а вместо того, чтобы обрабатывать
 * таким образом промис bdPromise.then(function ()) ... Просто в методе then вернуть
 * новый промис (return new Promise)
 *
 * Дальше можно снова обратиться к then, продолжив работу асинхронного кода, т.е.
 * дальше будет промис, который "трансформирует данные для клиента". Вызываем resolve()
 * после того как всё произошло
 *
 * И дальше осталось отправить на клиент "получил данные и отображаю их"
 *
 * catch() - можно вызывать в любом месте. Служит для обработки ошибки.
 * Если в callback в error придёт какая-то ошибка на любом этапе асинхронных операций,
 * то сразу можно обработать
 *
 * finally() - данный метод вызовется тогда, когда закончатся все асинхронные операции.
 * Если произойдёт ошибка в catch() и цепочка then() прервётся, то всё равно
 * вызовется данный метод
 *
 *
 * Добавим данные.
 * Допустим получили какие-то данные из БД (let users).
 * Теперь нужно через промисы передать эти данные дальше по цепочке.
 * Это реализуется через функцию resolve().
 * Если в данную функцию передать какие-то данные resolve(users), то они будут доступны
 * в следующей цепочке.
 * Для того чтобы получить доступ до users в следующей цепочке,
 * то получаем в следующем then() - например, назвав dbUsers.
 *
 * Далее, чтобы трансформировать dbUsers для клиентской части.
 * Метод map() модифицирует каждый элемент массива, и в результате возвращает новый массив.
 * И дальше передаём в resolve() трансформированный массив, чтобы передать его дальше по цепочке.
 *
 *
 */

console.log('Клиент: хочу получить список пользователей');
console.log('...');

// callback
// setTimeout(function() {
//   console.log('Сервер: запрашиваю список пользователей в БД')
//   console.log('...')
//
//   setTimeout(function() {
//     console.log('БД: формирую список пользователей')
//     console.log('...')
//
//     setTimeout(function() {
//       console.log('Сервер: трансформирую данные для клиента')
//       console.log('...')
//
//       setTimeout(function() {
//         console.log('Клиент: получил данные и отображаю их')
//       }, 1000)
//     }, 500)
//   }, 500)
// }, 1000)

// 1
let promise = new Promise(function (resolve, reject) {
    setTimeout(function () {
        console.log('Сервер: запрашиваю список пользователей в БД');
        console.log('...');
        resolve();
    }, 1000)
});

// 2
promise.then(function () {

    // Неверный подход
    // let bdPromise = new Promise(function (resolve, reject) {)...

    return new Promise(function (resolve, reject) {
        setTimeout(function () {

            // Как бы получили данные из БД
            let users = [
                {uid: 'id1', name: 'Maxim'},
                {uid: 'id2', name: 'Elena'}
            ];

            // Обработка ошибок, которая попадает в catch()
            //reject('БД не смогла получить список пользователей');
            console.log('БД: формирую список пользователей', users);
            console.log('...');

            resolve(users);
        }, 500);
    })

    // Неверный подход
    // bdPromise.then(function ()) ...
})
    .then(function (dbUsers) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                console.log('Сервер: трансформирую данные для клиента');
                console.log('...');

                // Трансформируем данные в users
                let users = dbUsers.map(function (user) {
                    return {
                        id: user.uid,
                        firstName: user.name,
                        timestamp: Date.now() // числовое значение времени в м/с
                    }
                });
                // Трансформированные данные
                resolve(users);
            }, 500)
        })
    })
    .then(function (users) {
        setTimeout(function () {
            // Отображение трансформированных данных
            console.log('Клиент: получил данные и отображаю их', users);
        }, 1000)
    })
    .catch(function (error) {
        console.error(error);
    })
// .finally(function() {
//   console.log('Finally')
// })