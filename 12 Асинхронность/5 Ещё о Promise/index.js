/**
 * Функции, которые облегчают работу при взаимодействии с асинхронными функциями
 *
 * sleep - эмуляция задержки через промисы. данная функция
 * будет обращаться к setTimeout и когда он будет выполнен
 * будет вызываться метод resolve
 *
 * Promise.all - синхронизация промисов p1, p2, p3(одновременное выполнение нескольких запросов)
 * Т.е. три промиса помещаются в один массив для того чтобы был один объект для работы с ними.
 * Данные промисы реализуются в разное время, но благодаря методу all все промисы будут отрабатывать
 * в один момент!
 * Срабатывают по самому долгому промису - через 4 сек сработают все три
 * all ждёт все промисы и только потом отрабатывает.
 *
 *
 * Promise.race схож на all, но он не дожидается всех промисов, а отрабатывает только тот промис,
 * который выполнился первым.
 * Промис попадает в then (если без await) только тогда, когда отрабатывает самый первый способ.
 * Это как гонки - кто первый тот и выиграл
 *
 * all и race возвращают промисы
 *
 * Так как all и race расположены в функции start, поэтому они отработают вместе, исходя из самого долгого промиса
 *
 *
 */

function sleep(ms) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            resolve();
        }, ms)
    });
}

// Через 1.5 сек
let p1 = sleep(1500).then(function () {
    return {
        name: 'Promise 1500'
    };
});

let p2 = sleep(3000).then(function () {
    return {
        name: 'Promise 3000'
    };
});

let p3 = sleep(4000).then(function () {
    return {
        name: 'Promise 4000'
    };
});

async function start() {
    let dataAll = await Promise.all([p1, p2, p3]);

    let dataRace = await Promise.race([p1, p2]);

    console.log('dataAll', dataAll);
    console.log('dataRace', dataRace);
}

start();

